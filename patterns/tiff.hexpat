#pragma description Tag Image File Format

#pragma MIME image/tiff

#pragma eval_depth 100

#include <std/io.pat>
#include <std/mem.pat>
#include <std/string.pat>
#include <std/core.pat>

u32 stripCount = 0;
s32 current_strip = 0;

fn get_next_strip_index(){
     if (current_strip <= stripCount) {
        current_strip = current_strip + 1;
        return current_strip - 1;
    } else {
        return stripCount+1;
    }
};

fn reset_counter_strip(){
    current_strip = 0;
    stripCount = 0;
};

fn start_counter_strip(u32 total){
    current_strip = 0;
    stripCount = total;
};

fn set_endian(str magic) {
    if (std::string::starts_with(magic, "II")) {
        std::core::set_endian(std::mem::Endian::Little);
    } else if (std::string::starts_with(magic, "MM")) {
        std::core::set_endian(std::mem::Endian::Big);
    } 
};

using TIFFFieldType;
using TIFFTag;
fn get_entry_value(u32 offset, TIFFTag Tag){
    u16 count = std::mem::read_unsigned(offset, 2, std::core::get_endian());
    u8 step = 12;
    offset = offset + 2;
    while (count != 0) {
        if (std::mem::read_unsigned(offset, 2, std::core::get_endian()) == Tag) {
            if (std::mem::read_unsigned(offset + 2, 2, std::core::get_endian()) == TIFFFieldType::SHORT) {
                return std::mem::read_unsigned(offset + 8, 2, std::core::get_endian());
            } else if (std::mem::read_unsigned(offset + 2, 2, std::core::get_endian()) == TIFFFieldType::LONG) {
                return std::mem::read_unsigned(offset + 8, 4, std::core::get_endian());
            }
        }
        count = count - 1;
        offset = offset + step;
    }
};


struct TIFFHeader {
    char Magic[2];
    set_endian(Magic);
    u16 Version;
    u32 Offset;
};

enum TIFFFieldType : u16 {
    BYTE = 1,
    ASCII = 2,
    SHORT = 3,
    LONG = 4,
    RATIONAL = 5,
    SBYTE = 6,
    UNDEFINED = 7,
    SSHORT = 8,
    SLONG = 9,
    SRATIONAL = 10,
    FLOAT = 11,
    DOUBLE = 12
};

struct TIFFRational<T> {
    T Numerator;
    T Denominator;
} [[format_read("format_read_rational")]];

fn format_read_rational(auto r) {
    return std::format("{}/{}", r.Numerator, r.Denominator);
};

enum TIFFTag : u16 {
    NewSubfileType = 0x00FE,
    SubfileType = 0x00FF,
    ImageWidth = 0x0100,
    ImageLength = 0x0101,
    BitsPerSample = 0x0102,
    Compression = 0x0103,
    PhotometricInterpretation = 0x0106,
    Threshholding = 0x0107,
    CellWidth = 0x0108,
    CellLength = 0x0109,
    FillOrder = 0x010A,
    DocumentName = 0x010D,
    ImageDescription = 0x010E,
    Make = 0x010F,
    Model = 0x0110,
    StripOffsets = 0x0111,
    Orientation = 0x0112,
    SamplesPerPixel = 0x0115,
    RowsPerStrip = 0x0116,
    StripByteCounts = 0x0117,
    MinSampleValue = 0x0118,
    MaxSampleValue = 0x0119,
    XResolution = 0x011A,
    YResolution = 0x011B,
    PlanarConfiguration = 0x011C,
    PageName = 0x011D,
    XPosition = 0x011E,
    YPosition = 0x011F,
    FreeOffsets = 0x0120,
    FreeByteCounts = 0x0121,
    GrayResponseUnit = 0x0122,
    GrayResponseCurve = 0x0123,
    T4Options = 0x0124,
    T6Options = 0x0125,
    ResolutionUnit = 0x0128,
    PageNumber = 0x0129,
    TransferFunction = 0x012D,
    Software = 0x0131,
    DateTime = 0x0132,
    Artist = 0x013B,
    HostComputer = 0x013C,
    Predictor = 0x013D,
    WhitePoint = 0x013E,
    PrimaryChromaticities = 0x013F,
    ColorMap = 0x0140,
    HalftoneHints = 0x0141,
    TileWidth = 0x0142,
    TileLength = 0x0143,
    TileOffsets = 0x0144,
    TileByteCounts = 0x0145,
    InkSet = 0x014C,
    InkNames = 0x014D,
    NumberOfInks = 0x014E,
    DotRange = 0x0150,
    TargetPrinter = 0x0151,
    ExtraSamples = 0x0152,
    SampleFormat = 0x0153,
    SMinSampleValue = 0x0154,
    SMaxSampleValue = 0x0155,
    TransferRange = 0x0156,
    JPEGTables = 0x015B,
    JPEGProc = 0x0200,
    JPEGInterchangeFormat = 0x0201,
    JPEGInterchangeFormatLngth = 0x0202,
    JPEGRestartInterval = 0x0203,
    JPEGLosslessPredictors = 0x0205,
    JPEGPointTransforms = 0x0206,
    JPEGQTables = 0x0207,
    JPEGDCTables = 0x0208,
    JPEGACTables = 0x0209,
    YCbCrCoefficients = 0x0211,
    YCbCrSubSampling = 0x0212,
    YCbCrPositioning = 0x0213,
    ReferenceBlackWhite = 0x0214,
    Copyright = 0x8298,
    ICCProfile = 0x8773
};


struct ValueArray<T, auto Count> {
    if (Count > 1) {
        T Values[Count];
    } else {
        T Values[Count] [[hidden, no_unique_address]];
        T Value;
    }
} [[inline]];

struct ValueOffset<T, auto Count> {
    u32 Size = sizeof(T) * Count;
    if (Size <= 4) {
        ValueArray<T, Count> ValueArray;
        padding[4 - Size];
    } else {
        u32 Offset;
        ValueArray<T, Count> ValueArray @ Offset;
    }
} [[inline]];

struct IFDEntry {
    TIFFTag Tag;
    TIFFFieldType Type;
    u32 Count;

    match (Type) {
        (TIFFFieldType::BYTE): ValueOffset<u8, Count> ValueOffset;
        (TIFFFieldType::ASCII): ValueOffset<char, Count> ValueOffset;
        (TIFFFieldType::SHORT): ValueOffset<u16, Count> ValueOffset;
        (TIFFFieldType::LONG): ValueOffset<u32, Count> ValueOffset;
        (TIFFFieldType::RATIONAL): ValueOffset<TIFFRational<u32>, Count> ValueOffset;
        (TIFFFieldType::SBYTE): ValueOffset<s8, Count> ValueOffset;
        (TIFFFieldType::UNDEFINED): ValueOffset<u8, Count> ValueOffset;
        (TIFFFieldType::SSHORT): ValueOffset<s16, Count> ValueOffset;
        (TIFFFieldType::SLONG): ValueOffset<s32, Count> ValueOffset;
        (TIFFFieldType::SRATIONAL): ValueOffset<TIFFRational<s32>, Count> ValueOffset;
        (TIFFFieldType::FLOAT): ValueOffset<float, Count> ValueOffset;
        (TIFFFieldType::DOUBLE): ValueOffset<double, Count> ValueOffset;
        (_): {
            padding[4];
            std::print("TIFFFieldType not supported");
        }
    }
} [[name(std::string::replace(std::core::formatted_value(Tag), "TIFFTag::", ""))]];


struct StripList {
    u16 entry_count [[hidden]];
    u32 ImageLength = get_entry_value(addressof(this), TIFFTag::ImageLength);
    u32 RowsPerStrip = get_entry_value(addressof(this), TIFFTag::RowsPerStrip);
    u32 StripByteCounts = get_entry_value(addressof(this), TIFFTag::StripByteCounts);
    u32 StripOffsets = get_entry_value(addressof(this), TIFFTag::StripOffsets);
    
    s32 next_strip_index = get_next_strip_index();  
    if ((ImageLength/RowsPerStrip) > 1) {
        u32 StripOffsetsArray[ImageLength/RowsPerStrip] @ StripOffsets [[hidden]];
        u32 StripByteCountsArray[ImageLength/RowsPerStrip] @ StripByteCounts [[hidden]];
        u8 Strip[StripByteCountsArray[next_strip_index]] @ StripOffsetsArray[next_strip_index];
    } else {
        u8 Strip[StripByteCounts] @ StripOffsets;
    }

    if (current_strip < stripCount)  {
        StripList strips @ addressof(this);
    } else {
        reset_counter_strip();
        break;
    }

}[[inline]];


u32 currentIFD = 0;
struct IFD {
    u32 Number = currentIFD;
    u16 NumberDirectoryEntries;
    IFDEntry DirectoryEntry[NumberDirectoryEntries];
    u32 NextIFD;
    u32 ImageLength = get_entry_value(addressof(this), TIFFTag::ImageLength);
    u32 RowsPerStrip = get_entry_value(addressof(this), TIFFTag::RowsPerStrip);
    u32 StripByteCounts = get_entry_value(addressof(this), TIFFTag::StripByteCounts);
    u32 StripOffsets = get_entry_value(addressof(this), TIFFTag::StripOffsets);
    u32 StripOffsetsArray[ImageLength/RowsPerStrip] @ StripOffsets;
    u32 StripByteCountsArray[ImageLength/RowsPerStrip] @ StripByteCounts;
    start_counter_strip(ImageLength/RowsPerStrip);
    StripList ImageData[] @ addressof(this);
} [[name(std::format("IFD {}", Number))]];

struct IFDS {
    IFD IFD;
    if (IFD.NextIFD > 0) {
        currentIFD += 1;
        IFDS IFD_tmp  @ IFD.NextIFD;
    }
}[[inline]];

struct TIFFFile {
    TIFFHeader Header;
    set_endian(Header.Magic);
    IFDS @ Header.Offset;
};


TIFFFile File @ 0x00;
